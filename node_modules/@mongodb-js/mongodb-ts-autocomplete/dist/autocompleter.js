"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDBAutocompleter = void 0;
const ts_autocomplete_1 = __importDefault(require("@mongodb-js/ts-autocomplete"));
const autocomplete_types_1 = __importDefault(require("./fixtures/autocomplete-types"));
const api_1 = require("@mongosh/shell-api/api");
const utils_1 = require("./utils");
const mongodb_schema_1 = require("mongodb-schema");
const cdt_analyser_1 = require("./cdt-analyser");
const autocompletion_context_1 = require("./autocompletion-context");
class DatabaseSchema {
    constructor() {
        this.collectionSchemas = Object.create(null);
    }
    setCollectionNames(collectionNames) {
        for (const collectionName of collectionNames) {
            if (!this.collectionSchemas[collectionName]) {
                this.collectionSchemas[collectionName] = undefined;
            }
        }
        const knownCollectionNames = new Set(collectionNames);
        for (const key of Object.keys(this.collectionSchemas)) {
            if (!knownCollectionNames.has(key)) {
                delete this.collectionSchemas[key];
            }
        }
    }
    setCollectionSchema(collectionName, schema) {
        this.collectionSchemas[collectionName] = schema;
    }
    toTypescriptTypeDefinition() {
        const collectionProperties = Object.entries(this.collectionSchemas).map(([collectionName, schema]) => {
            const def = schema ? (0, mongodb_schema_1.toTypescriptTypeDefinition)(schema) : `{}`;
            const lines = def.split(/\n/g).map((line) => `      ${line}`);
            return `  ${JSON.stringify(collectionName)}: {
      schema: ${lines.join('\n').trim()}
    };`;
        });
        return `{
  ${collectionProperties.join('\n')}
  }`;
    }
}
class ConnectionSchema {
    constructor() {
        this.databaseSchemas = Object.create(null);
    }
    addDatabase(databaseName) {
        if (!this.databaseSchemas[databaseName]) {
            this.databaseSchemas[databaseName] = new DatabaseSchema();
        }
    }
    setDatabaseCollectionNames(databaseName, collectionNames) {
        this.addDatabase(databaseName);
        this.databaseSchemas[databaseName].setCollectionNames(collectionNames);
    }
    addCollectionSchema(databaseName, collectionName, collectionSchema) {
        this.addDatabase(databaseName);
        this.databaseSchemas[databaseName].setCollectionSchema(collectionName, collectionSchema);
    }
    toTypescriptTypeDefinition() {
        const databaseProperties = Object.entries(this.databaseSchemas).map(([databaseName, schema]) => {
            const def = schema.toTypescriptTypeDefinition();
            return `${JSON.stringify(databaseName)}: ${def}`;
        });
        return `{
  ${databaseProperties.join('\n')}
}`;
    }
}
function filterStartingWith({ kind, name, trigger, }) {
    name = name.toLocaleLowerCase();
    trigger = trigger.toLocaleLowerCase();
    return ((trigger !== '' || kind === 'property' || kind === 'method') &&
        name.startsWith(trigger));
}
class MongoDBAutocompleter {
    constructor({ context }) {
        this.context = autocompletion_context_1.CachingAutocompletionContext.caching(context);
        this.autocompleter = new ts_autocomplete_1.default({ filter: filterStartingWith });
        this.connectionSchemas = Object.create(null);
        this.autocompleter.updateCode({
            ...autocomplete_types_1.default,
            '/shell-api.ts': (0, utils_1.replaceImports)(api_1.api),
        });
    }
    addConnection(connectionId) {
        if (!this.connectionSchemas[connectionId]) {
            this.connectionSchemas[connectionId] = new ConnectionSchema();
        }
        return this.connectionSchemas[connectionId];
    }
    getConnectionCode(connectionId) {
        return `
import * as ShellAPI from '/shell-api.ts';
import * as bson from '/bson.ts';

export type ServerSchema = ${this.connectionSchemas[connectionId].toTypescriptTypeDefinition()};
`;
    }
    getCurrentGlobalsCode(connectionId, databaseName) {
        return `
import * as ShellAPI from '/shell-api.ts';
import { ServerSchema } from '/${connectionId}.ts';

type CurrentDatabaseSchema = ServerSchema[${JSON.stringify(databaseName)}];

declare global {
  const db: ShellAPI.DatabaseWithSchema<ServerSchema, CurrentDatabaseSchema>;
  const rs: ShellAPI.ReplicaSet<ServerSchema, CurrentDatabaseSchema>;
  const sh: ShellAPI.Shard<ServerSchema, CurrentDatabaseSchema>;
  const sp: ShellAPI.Streams<ServerSchema, CurrentDatabaseSchema>;
}
`;
    }
    async autocomplete(code) {
        const dbAndConnection = this.context.currentDatabaseAndConnection();
        if (!dbAndConnection) {
            return [];
        }
        const { connectionId, databaseName } = dbAndConnection;
        const tsAst = (0, cdt_analyser_1.compileSourceFile)(code);
        const collectionName = (0, cdt_analyser_1.inferCollectionNameFromFunctionCall)(tsAst) || 'test';
        const schema = await this.context.schemaInformationForCollection(connectionId, databaseName, collectionName);
        const connection = this.addConnection(connectionId);
        connection.addCollectionSchema(databaseName, collectionName, schema);
        const collectionNames = await this.context.collectionsForDatabase(connectionId, databaseName);
        connection.setDatabaseCollectionNames(databaseName, collectionNames);
        this.autocompleter.updateCode({
            [`/${connectionId}.ts`]: this.getConnectionCode(connectionId),
        });
        this.autocompleter.updateCode({
            '/current-globals.ts': this.getCurrentGlobalsCode(connectionId, databaseName),
        });
        return this.autocompleter.autocomplete(code);
    }
}
exports.MongoDBAutocompleter = MongoDBAutocompleter;
//# sourceMappingURL=autocompleter.js.map